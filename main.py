import numpy as np
import matplotlib.pyplot as plt


def solve_nand_dynamics_fixed():
    # ==========================================
    # 1. Параметры схемы
    # ==========================================
    C_zi = 5e-12
    C_si = 5e-12
    C_n = 50e-12

    S = 10e-3
    U_p = 5.0

    # Входные сигналы (Логическая 1 на обоих входах открывает транзисторы)
    u_zi1 = 5.0
    u_zi2 = 5.0

    # Временные параметры
    t_end = 20e-9  # Увеличил до 20 нс, чтобы точно увидеть разряд до конца
    N = 2000
    h = t_end / N

    time = np.linspace(0, t_end, N)
    U_Csi1 = np.zeros(N)
    U_Csi2 = np.zeros(N)
    U_Cn = np.zeros(N)

    # ==========================================
    # 2. Начальные условия
    # ==========================================
    # Делим напряжение питания пополам между двумя транзисторами
    U_Csi1[0] = U_p / 2
    U_Csi2[0] = U_p / 2
    U_Cn[0] = U_Csi1[0] + U_Csi2[0]

    # ==========================================
    # 3. Расчет коэффициентов
    # ==========================================
    # Знаменатель
    D = 3 * C_si + 2 * C_zi + 2 * C_n

    # Коэффициенты для уравнения dU_Csi2 / dt
    K1 = (S * (C_zi + C_si + C_n)) / (C_si * D)
    K2 = (S * (C_zi + 2 * C_si + C_n)) / (C_si * D)
    K3 = S / D

    # Коэффициент связи
    K_cross = S / C_si

    # ==========================================
    # 4. Основной цикл (Метод Эйлера с отсечкой)
    # ==========================================
    for n in range(N - 1):
        uc1 = U_Csi1[n]
        uc2 = U_Csi2[n]

        # --- ФИЗИЧЕСКОЕ ИСПРАВЛЕНИЕ ---
        # Если напряжения уже 0, то дальше они не меняются (разряд окончен)
        if uc1 <= 0 and uc2 <= 0:
            U_Csi1[n + 1] = 0
            U_Csi2[n + 1] = 0
            U_Cn[n + 1] = 0
            continue

        # Считаем производные по формулам из текста
        dU2_dt = (K1 * u_zi1) - (K2 * u_zi2) - K3 * (U_p + uc1 + uc2)
        dU1_dt = dU2_dt - (K_cross * u_zi1) + (K_cross * u_zi2)

        # Делаем шаг Эйлера
        next_uc1 = uc1 + h * dU1_dt
        next_uc2 = uc2 + h * dU2_dt

        # --- ОГРАНИЧЕНИЕ (CLAMPING) ---
        # Не даем напряжению уйти в минус
        if next_uc1 < 0: next_uc1 = 0
        if next_uc2 < 0: next_uc2 = 0

        U_Csi1[n + 1] = next_uc1
        U_Csi2[n + 1] = next_uc2

        # Выходное напряжение
        U_Cn[n + 1] = U_Csi1[n + 1] + U_Csi2[n + 1]

    # ==========================================
    # 5. Визуализация
    # ==========================================
    plt.figure(figsize=(10, 6))

    # Выходной сигнал (Красный)
    plt.plot(time * 1e9, U_Cn, 'r-', linewidth=2, label=r'$U_{C_н}$ (Выход)')

    # Нижний транзистор (Зеленый) - ТОЛСТАЯ линия
    plt.plot(time * 1e9, U_Csi1, 'g-', linewidth=5, alpha=0.4, label=r'$U_{C_{си1}}$ (Нижний)')

    # Верхний транзистор (Синий) - Тонкий пунктир поверх зеленой
    plt.plot(time * 1e9, U_Csi2, 'b--', linewidth=1.5, label=r'$U_{C_{си2}}$ (Верхний)')

    plt.title('Лаб 2: Переходный процесс И-НЕ (с учетом отсечки тока)')
    plt.xlabel('Время (нс)')
    plt.ylabel('Напряжение (В)')
    plt.grid(True)
    plt.legend()

    # Печатаем результаты в консоль
    print(f"Входы: {u_zi1} В и {u_zi2} В")
    print(f"Выход Start: {U_Cn[0]:.2f} В")
    print(f"Выход End:   {U_Cn[-1]:.2f} В")  # Теперь здесь будет 0.00

    plt.show()


if __name__ == "__main__":
    solve_nand_dynamics_fixed()